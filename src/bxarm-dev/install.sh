#!/usr/bin/env bash

#!/usr/bin/env bash
set -uxvT -o pipefail
set -e

. /etc/os-release

# Determine base Linux distribution
if [[ "${ID}" != "debian" && ! "${ID_LIKE}" =~ "debian" ]]; then
    echo "Error: Unsupported Linux distribution '${ID}'."
    exit 1
fi

pkg_mgr_update() {
    apt-get update -y
}


verify_architecture() {
    if [[ "$(uname -m)" != "x86_64" ]]; then
        echo "Error: Unsupported architecture '$(uname -m)'. BXARM is only available for x86_64."
        exit 1
    fi
}

check_packages() {
    apt-get install -y --no-install-recommends "$@"
}

install_dependencies() {
    check_packages libusb-1.0-0 wget ca-certificates gettext texinfo cpio file locales git-lfs
    locale-gen en_US.UTF-8
    
    wget --progress=dot:giga https://github.com/mikefarah/yq/releases/download/v"${YQ_VERSION}"/yq_linux_amd64.tar.gz -O - |\
                tar xz && mv yq_linux_amd64 /usr/bin/yq

    cat << 'EOF' > /etc/profile.d/devcontainer-feature-bxarm.sh
#!/usr/bin/env bash
export PATH="$PATH:/opt/iarsystems/bxarm/common/bin/:/opt/iarsystems/bxarm/arm/bin/"

build_with_bxarm() {
  info() {
      local input="$*"
      # color: white
      echo -e "\033[0m[INFO] $input\033[0m" >&2
  }

  fatal() {
      error() {
          local input="$*"
          # color: red
          echo -e "\033[31m[ERROR] $input\033[0m"
      }

      local input="$*"
      error "${input}"
      exit 1
  }

  if [[ -z "$IAR_LICENSE_SERVER" ]]; then
    echo "[ERROR] IAR_LICENSE_SERVER is unset or empty. Please verify your configuration and try again."
    exit 1
  fi

  # this has the lightlicensemanager and iarbuild programs
  lightlicensemanager setup --host "${IAR_LICENSE_SERVER}"

  set_iar_log_level() {
    get_iar_config_path () {
          EO_CONFIG_ROOT=.embedops
          IAR_CONFIG_PATH=${EO_CONFIG_ROOT}/iar/config.yml
          IAR_ENVSUBST_CONFIG_PATH=${EO_CONFIG_ROOT}/iar/envsubst.config.yml
          if [[ -f ${IAR_CONFIG_PATH} ]]
          then
              envsubst < ${IAR_CONFIG_PATH} > ${IAR_ENVSUBST_CONFIG_PATH}
              echo ${IAR_ENVSUBST_CONFIG_PATH}
          else
              info "file not found: ${EO_CONFIG_ROOT}/iar/config.yml"
              exit 1
          fi
      }

      IAR_CONFIG_PATH=$(get_iar_config_path)

      get_iar_config () {
          if [[ -f ${IAR_CONFIG_PATH} ]]
          then
              VAL="$(yq eval "${1}" "${IAR_CONFIG_PATH}")"
              # file exists, but variable not set
              if [[ "${VAL}" != "null" ]]
              then
                  echo "${VAL}"
              fi
          fi
      }

      # if not set or null, then try to get log level from .embedops/iar/config.yml
      IAR_LOG_LEVEL=${IAR_LOG_LEVEL:-$(get_iar_config '.IAR_LOG_LEVEL')}
      # if still no value for log level, default to 'all'
      IAR_LOG_LEVEL=${IAR_LOG_LEVEL:-all}

      IAR_LOG_LEVELS=("errors" "warnings" "info" "all")
      found=false

      for level in "${IAR_LOG_LEVELS[@]}"
      do
          if [[ "$level" == "$IAR_LOG_LEVEL" ]]; then
              found=true
              break
          fi
      done

      if [[ "$found" == true ]]; then
          IAR_LOG_SETTING="-log ${IAR_LOG_LEVEL}"
          info "using IAR log level: ${IAR_LOG_LEVEL}"
      else
          error "Using unsupported IAR log level: ${IAR_LOG_LEVEL}"
          fatal "IAR log level must be one of: ${IAR_LOG_LEVELS[*]}"
      fi
  }

  set_iar_log_level
  set +u -eE -o pipefail
  export EMBEDOPS_COMPILER=IAR
  export EMBEDOPS_INPUT_FILE=build.log

  if [ -n "$IAR_CONFIG_PATH" ]; then
      set -u
      readarray iarBuildTargetsMappings < <(yq -o=j -I=0 '.IAR_BUILD_TARGETS[]' "$IAR_CONFIG_PATH" )
      for iarBuildTargetsMapping in "${iarBuildTargetsMappings[@]}"; do
          # identity mapping is a single json snippet representing a single entry
          PROJECT_FILE=$(echo "$iarBuildTargetsMapping" | yq '.PROJECT_FILE' -)
          CONFIGURATION=$(echo "$iarBuildTargetsMapping" | yq '.CONFIGURATION' -)
          if [ "$PROJECT_FILE" = "null" ] || [ "$CONFIGURATION" = "null" ]; then
              echo "Bad configuration: IAR_BUILD_TARGET must contain the fields PROJECT_FILE and CONFIGURATION"
              exit 1
          else
              # record current time to serach within files generated after
              timestamp=$(date +"%Y-%m-%d %H:%M:%S")
              iarbuild "$PROJECT_FILE" -build "$CONFIGURATION" -parallel "$(nproc)" $IAR_LOG_SETTING | tee -a "$EMBEDOPS_INPUT_FILE" 2>&1

              # used captured time to determine all new ELF files generated by build
              set +eE # only want to convert if possible. build should succeed even if conversions fail
              # convert elf to srec and bin
              find . -type f -newermt "${timestamp}" -not -name "*.o" -exec bash -c '[[ "$(file $1)" == *"ELF"*"executable"* ]]' -- {} \; -print | while IFS= read -r file; do
                  ielftool --srec "$file" "${file%.*}.srec"
                  ielftool --bin "$file" "${file%.*}.bin"
              done
          fi
      done
      rm "$IAR_CONFIG_PATH"
  else # if any argument, assume build script
      set -u
      "$@" | tee "$EMBEDOPS_INPUT_FILE" 2>&1
      # NOTE: telemetry not reported in this case
  fi

  if [[ -n ${EMBEDOPS_JOB_NAME} ]]
  then
      JOB_ARTIFACT_PATH=artifacts/${EMBEDOPS_JOB_NAME}
      mkdir -p "${JOB_ARTIFACT_PATH}"
      find . -name "*.hex" -not -path "./artifacts/*" | cpio -pdm "${JOB_ARTIFACT_PATH}"
      # shellcheck disable=SC2086
      find . -name "*.out" -not -path "./artifacts/*" | cpio -pdm ${JOB_ARTIFACT_PATH}
      find . -name "*.elf" -not -path "./artifacts/*" | cpio -pdm "${JOB_ARTIFACT_PATH}"
      # shellcheck disable=SC2086
      find . -name "*.map" -not -path "./artifacts/*" | cpio -pdm ${JOB_ARTIFACT_PATH}
      # shellcheck disable=SC2086
      find . -name "*.srec" -not -path "./artifacts/*" | cpio -pdm ${JOB_ARTIFACT_PATH}
      find . -name "*.bin" -not -path "./artifacts/*" | cpio -pdm "${JOB_ARTIFACT_PATH}"
      # shellcheck disable=SC2086
      find . -name "*.stztef" -not -path "./artifacts/*" | cpio -pdm ${JOB_ARTIFACT_PATH}
  else
      info "EMBEDOPS_JOB_NAME environment variable not set"
      exit 1
  fi
}
EOF
    EMBEDOPS_JOB_NAME="${EMBEDOPS_JOB_NAME:-iar}"
    echo "export EMBEDOPS_JOB_NAME=\"${EMBEDOPS_JOB_NAME}\";export BXARM_DEB_PATH=\"${BXARM_DEB_PATH}\";export IAR_LICENSE_SERVER=\"${IAR_LICENSE_SERVER}\";" >> /etc/profile.d/devcontainer-feature-bxarm.sh
    echo "source /etc/profile.d/devcontainer-feature-bxarm.sh" >> /etc/bash.bashrc
    chmod +x /etc/profile.d/devcontainer-feature-bxarm.sh

    cat << 'EOF' > /usr/local/bin/build_with_bxarm
#!/usr/bin/env bash
source /etc/profile.d/devcontainer-feature-bxarm.sh
build_with_bxarm
EOF

    chmod +x /usr/local/bin/build_with_bxarm
}

clean() {
  apt-get clean
  rm -rf /var/lib/apt/lists/*
}

main() {
    echo "Starting BXARM installation process..."
    verify_architecture
    pkg_mgr_update
    install_dependencies
    clean
    install -m 755 bxarm-setup.sh /usr/local/bin
    echo "BXARM installation process completed successfully"
}

main "$@"